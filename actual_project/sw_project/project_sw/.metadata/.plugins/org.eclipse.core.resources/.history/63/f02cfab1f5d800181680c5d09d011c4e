.text

.global asm_mont_mul_loop
.func asm_mont_mul_loop, asm_mont_mul_loop
.type asm_mont_mul_loop, %function

// r0: a
// r1: b
// r2: t
// r3: size
// r4: i
// r5: j
// r6: c
asm_mont_mul_loop:
// Push previous registers?
push {r4-r12}

// Setting all elements of t to zero
mov r4, #0	// r4: i = 0
mov r5, #0
mov r6, r3, lsl #1	// r6: size*2
t_loop:
	str r5, [r2, r4, lsl #2]	// r5: t[i]
	add r4, r4, #1
	cmp r4, r6
	blt t_loop

// Actual multiplication
mov r4, #0							// r4: i = 0
outer_loop:
	mov r6, #0						// r6: c = 0
	mov r5, #0						// r5: j = 0
	inner_loop:
		ldr r8, [r0, r5, lsl #2]	// r8: a[j]
		ldr r9, [r1, r4, lsl #2]	// r9: b[i]
		add r12, r4, r5				// r12: i + j
		// ldr r10, [r2, r12, lsl #2]	// r10: t[i+j]
		// mov r11, #0					// upper register = 0
		// umlal r10, r11, r8, r9
		umull r10, r11, r8, r9		// [r11, r10] = a[j] * b[i]
		ldr r8, [r2, r12, lsl #2]	// r8: t[i+j]
		adds r10, r10, r8			// r10: (a[j]*b[i])lsb + t[i+j]
		adc r11, r11, #0
		adds r10, r10, r6
		adc r6, r11, #0				// r6: update c
		str r10, [r2, r12, lsl #2]  // t[i+j] = s

		add r5, r5, #1
		cmp r5, r3
		blt inner_loop

	add r12, r3, r4
	str r10, [r2, r12, lsl #2]  // t[i+size] = c
	add r4, r4, #1
	cmp r4, r3
	blt outer_loop

pop {r4-r12}
bx lr
.endfunc


			uint64_t sum = (uint64_t)t[i+j] + (uint64_t)a[j] * (uint64_t)b[i] + (uint64_t)c;
			uint32_t s = (uint32_t)sum;
			c = (uint32_t)(sum >> 32);
			t[i+j] = s;
		}
		t[i+SIZE] = c;



