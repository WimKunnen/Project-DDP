// Complete montgomery algorithm in assembly
.text

.global asm_mont
.func asm_mont, asm_mont
.type asm_mont, %function

// void asm_mont(uint32_t *a, uint32_t *b, uint32_t *n, uint32_t *n0, uint32_t *res, uint32_t SIZE);
// r0: &a
// r1: &b
// r2: &n
// r3: &n0
// stack: res, SIZE
// SIZE will always be 32
asm_mont:
	// Store saved registers
	push {r4-r12, lr}
	// Load stack parameters and swap around registers
	mov r4, r2			// r4: n
	ldr r5, [sp, #40]	// r5: res

	// Allocate t[65] on stack
	sub sp, sp, #260
	mov r2, sp		// r2: t

	// Store function arguments (n, n0, res) on stack for later
	push {r3-r5}

	// Make t contain only zeros
	mov r3, r2
	mov r4, #0
	mov r5, #0
	mov r6, #0
	mov r7, #0
	mov r8, #0
	mov r9, #0
	mov r10, #0
	mov r11, #0
	mov r12, #0
	stmia r3!, {r4-r12}
	stmia r3!, {r4-r12}
	stmia r3!, {r4-r12}
	stmia r3!, {r4-r12}
	stmia r3!, {r4-r12}
	stmia r3!, {r4-r12}
	stmia r3!, {r4-r12}
	stmia r3!, {r4-r5}


	// Multiplication loop:
	// asm_mont_mul_loop(uint32_t *a, uint32_t *b, uint32_t *t, uint32_t SIZE);
	// r0: &a
	// r1: &b
	// r2: &t
	// r3: SIZE = 32
	// TODO

	// Reduction loop
	pop {r3-r5}
	// TODO


	// Conditional subtraction
	// TODO


	// Restore stach pointer (t[65] goes out of scope)
	add sp, sp, #260
	
	// Restore saved registers
	pop {r4-r12, lr}

	bx lr
.endfunc
